{
  "_args": [
    [
      {
        "raw": "lru-fast@github:sgratzl/js-lru",
        "scope": null,
        "escapedName": "lru-fast",
        "name": "lru-fast",
        "rawSpec": "github:sgratzl/js-lru",
        "spec": "github:sgratzl/js-lru",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:sgratzl/js-lru.git",
          "sshUrl": "git+ssh://git@github.com/sgratzl/js-lru.git",
          "httpsUrl": "git+https://github.com/sgratzl/js-lru.git",
          "gitUrl": "git://github.com/sgratzl/js-lru.git",
          "shortcut": "github:sgratzl/js-lru",
          "directUrl": "https://raw.githubusercontent.com/sgratzl/js-lru/master/package.json"
        }
      },
      "/Users/hanmengjiao/Desktop/VisLab/UpsetPhovea"
    ]
  ],
  "_from": "sgratzl/js-lru",
  "_id": "lru-fast@0.1.0",
  "_inCache": true,
  "_location": "/lru-fast",
  "_phantomChildren": {},
  "_requested": {
    "raw": "lru-fast@github:sgratzl/js-lru",
    "scope": null,
    "escapedName": "lru-fast",
    "name": "lru-fast",
    "rawSpec": "github:sgratzl/js-lru",
    "spec": "github:sgratzl/js-lru",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:sgratzl/js-lru.git",
      "sshUrl": "git+ssh://git@github.com/sgratzl/js-lru.git",
      "httpsUrl": "git+https://github.com/sgratzl/js-lru.git",
      "gitUrl": "git://github.com/sgratzl/js-lru.git",
      "shortcut": "github:sgratzl/js-lru",
      "directUrl": "https://raw.githubusercontent.com/sgratzl/js-lru/master/package.json"
    }
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git://github.com/sgratzl/js-lru.git#c2a5affe66c0338f9aacf1854c70ee03048e1e03",
  "_shasum": "9728e2bea94d82c74320f75a1078b81905a55411",
  "_shrinkwrap": null,
  "_spec": "lru-fast@github:sgratzl/js-lru",
  "_where": "/Users/hanmengjiao/Desktop/VisLab/UpsetPhovea",
  "author": {
    "name": "Rasmus Andersson",
    "email": "me@rsms.me"
  },
  "bugs": {
    "url": "https://github.com/rsms/js-lru/issues"
  },
  "dependencies": {},
  "description": "finite key-value cache using the Least Recently Used (LRU) algorithm where the most recently used objects are keept in cache while less recently used items are purged",
  "devDependencies": {},
  "gitHead": "c2a5affe66c0338f9aacf1854c70ee03048e1e03",
  "homepage": "https://github.com/rsms/js-lru#readme",
  "keywords": [
    "cache",
    "lru",
    "buffer"
  ],
  "license": "MIT",
  "main": "lru.js",
  "name": "lru-fast",
  "optionalDependencies": {},
  "readme": "# Least Recently Used (LRU) cache algorithm\n\nA finite key-value cache using the [Least Recently Used (LRU)](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) cache algorithm where the most recently used objects are keept in cache while less recently used items are purged.\n\nThis implementation is compatible with most JavaScript environments (including ye olde browser) and is very efficient.\n\n## Terminology & design\n\n- Based on a doubly-linked list for low complexity random shuffling of entries.\n\n- The cache object iself has a \"head\" (least recently used entry) and a\n  \"tail\" (most recently used entry).\n\n- The \"head\" and \"tail\" are \"entries\" -- an entry might have a \"newer\" and\n  an \"older\" entry (doubly-linked, \"older\" being close to \"head\" and \"newer\"\n  being closer to \"tail\").\n\n- Key lookup is done through a key-entry mapping native object, which on most \n  platforms mean `O(1)` complexity. This comes at a very low memory cost  (for \n  storing two extra pointers for each entry).\n\nFancy ASCII art illustration of the general design:\n\n        entry             entry             entry             entry        \n        ______            ______            ______            ______       \n       | head |.newer => |      |.newer => |      |.newer => | tail |      \n       |  A   |          |  B   |          |  C   |          |  D   |      \n       |______| <= older.|______| <= older.|______| <= older.|______|      \n                                                                           \n    removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n\n## Example\n\n    var c = new LRUCache(3);\n    c.put('adam', 29);\n    c.put('john', 26);\n    c.put('angela', 24);\n    c.toString();        // -> \"adam:29 < john:26 < angela:24\"\n    c.get('john');       // -> 26\n    // Now 'john' is the most recently used entry, since we just requested it\n    c.toString();        // -> \"adam:29 < angela:24 < john:26\"\n    c.put('zorro', 141); // -> {key:adam, value:29}\n    // Because we only have room for 3 entries, put-ing 'zorro' purged 'adam'\n    c.toString();        // -> \"angela:24 < john:26 < zorro:141\"\n\n# Usage\n\nJust copy the code on lru.js â€” for minimal functionality, you only need the lines up until the comment that says \"Following code is optional\".\n\nIf you're really into package managers and love having lots of complicated little files in your project, you can use `npm install lru-fast`\n\n# API\n\nAn entry is a simple `Object` with at least two members: `{key:Object, value:Object}`. An entry might also have a `newer` member which points to a newer entry, and/or a `older` member pointing to an older entry.\n\n### new LRUCache(Number limit) -> LRUCache instance\n\nCreates a new cache object which will hold up to `limit` entries.\n\n### *LRUCache.prototype*.size -> Number\n\nCurrent number of entries. Read-only.\n\n### *LRUCache.prototype*.limit <-> Number\n\nMaximum number of items this cache will keep.\n\n### *LRUCache.prototype*.put (Object key, Object value) -> Object entry\n\nPut `value` into the cache associated with `key`.\n\n**Returns an entry which was removed** (to make room for the new entry) or  `undefined` if there was enough space for the new entry.\n\n> **Note:** The returned entry does **not** include any (strong) references to other entries (i.e. there is no `older` or `newer` members). This design makes garbage collection predictable.\n\n### *LRUCache.prototype*.get (Object key) -> Object value\n\nRetrieve value for, and register recent use of, `key`. Returns the value associated with `key` or `undefined` if not in the cache.\n\n### *LRUCache.prototype*.find (Object key) -> Object entry\n\nCheck if `key` is in the cache *without registering recent use*. Feasible if\nyou do not want to chage the state of the cache, but only \"peek\" at it.\nReturns the entry associated with `key` if found, otherwise `undefined` is\nreturned.\n\n> **Note:** The entry returned is *managed by the cache* (until purged) and thus contains members with strong references which might be altered at any time by the cache object. You should look at the returned entry as being immutable.\n\n### *LRUCache.prototype*.shift () -> Object entry\n\nRemove the least recently used (oldest) entry. Returns the removed entry, or `undefined` if the cache was empty.\n\nIf you need to perform any form of finalization of purged items, this is a good place to do it. Simply override/replace this function:\n\n    var c = new LRUCache(123);\n    c.shift = function() {\n      var entry = LRUCache.prototype.shift.call(this);\n      doSomethingWith(entry);\n      return entry;\n    }\n\nThe returned entry must not include any strong references to other entries. See note in the documentation of `LRUCache.prototype.put (Object key, Object value) -> Object entry`.\n\n### *LRUCache.prototype*.set (key, value) -> Object oldValue\n\nUpdate the value of entry with `key` or `put` a new entry. Returns the old value, or undefined if the cache was empty.\n\n### *LRUCache.prototype*.remove (key) -> Object value\n\nRemove entry `key` from cache and return its value. Returns `undefined` if `key` is not found.\n\n### *LRUCache.prototype*.removeAll () -> LRUCache instance\n\nRemoves all entries and return itself.\n\n### *LRUCache.prototype*.keys () -> Array keys\n\nReturn an array containing all keys of entries in arbitrary order.\n\n### *LRUCache.prototype*.forEach (fun, [Object context, Boolean desc | true])\n\nCall `fun` for each entry. Starting with the newest entry if `desc` is a true\nvalue, otherwise starts with the oldest (head) enrty and moves towards the\ntail.\n\nReturns nothing (`undefined`).\n\n`fun` is called with 3 arguments in the context `context`:\n\n    fun.call(context, Object key, Object value, LRUCache self)\n\nExample which prints \"key: value\" starting with the most recent entry:\n\n    cache.forEach(function(key, value) {\n      puts(key+': '+value);\n    }, true);\n\n\n### *LRUCache.prototype*.toJSON () -> Array representation\n\nReturns an array of object (for use by `JSON.stringify`) of the form:\n\n    [\n      {key:\"key1\", value:\"value1\"},\n      {key:\"key2\", value:\"value2\"},\n      {key:\"key3\", value:\"value3\"}\n    ]\n\n### *LRUCache.prototype*.toString () -> String representation\n\nReturns a string representation in the format:\n\n    key1:value1 < key2:value2 < key3:value3\n\nOldest (head) on the left hand side and newer entries to the right hand side.\n\n## Factorising a minimal implementation\n\nAs this code is most suitable for embedding, here is a shortlist of the essential parts (prototype functions) needed for a minimal implementation. All other functions, not mentioned here, are simply ancillary.\n\n- **LRUCache** -- the constructor is naturally a good thing to keep ;)\n- *LRUCache.prototype*.**put** -- handles appending and chaining.\n- *LRUCache.prototype*.**shift** -- used by **put** to \"purge\" an old entry.\n- *LRUCache.prototype*.**get** -- fetches a cached entry and registers that entry as being recently used.\n\nThe border between \"required\" and \"optional\" code is marked in `lru.js` by a comment starting with `// Following code is optional`...\n\n# MIT license\n\nCopyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rsms/js-lru.git"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "typings": "lru.d.ts",
  "version": "0.1.0"
}
